=== Nedded ===
Lua 5.1
PortAudio v19
FFTW3
GNU Readline (optional, but recommended)
CMake >= 2.6

=== Build instructions ===

Linux:
    $ mkdir build
    $ cd build
    $ ccmake ..
    Press c
    Edit options (if you want/have to)
    Press c again
    Press g to generate Makefile
    $ make

OSX (not tested or even known):
    Probably the same as on Linux, but there should
    be a way to create a XCode project.

Windows (not tested):
    Use CMakeSetup.exe to generate a Makefile.
    Compile.


=== Usage & Example ===
To use:
    $ ./lhc
    <type lua code>

Example:
    $ ./lhc 
    >> -- play some signals
    >> saw = sig{gen.saw, f=220}
    >> saw:play()
    >> saw:stop()
    >> sin = sig{gen.sin, f=440}
    >> sin:play()
    >> signals.stop()
    
    >> -- mix samples 
    >> sawsin = sin * .7 + saw * .3
    >> sawsin:play()
    >> sawsin:stop()
    
    >> -- modulate signals
    >> mod = sig{gen.sin,f=100} * sig{gen.triangle,f=1}
    >> mod:play()
    >> mod:stop()

    >> -- the frequency can be a function, too:
    >> length = 30
    >> function rise(t) return 300 * (1 + t / length) + gen.sin(t) end
    >> r = sig{gen.sin, f=rise}
    >> r:play()
    >> r:stop()

    >> -- envelope!
    >> g = sig{gen.sin,f=200} * function(t) math.exp(-x*x)
    >> g:play()
    >> g:stop()

    >> -- subtractive synthesis is fun!
    >> flow = sig{gen.bn}:lp(440)
    >> flow:play()
    >> t = sig{gen.wn}:bp{{440,445}, {660,667}, {878,884}}
    >> t:play() -- this is way too quiet
    >> t:stop()
    >> t2 = t:normalize(.9)
    >> t2:play()

    >> -- TIMER! actual working example
    >> function fall(l)
    ..     return function(t)
    ..         if t > l then return 0 end
    ..         return 1 - t / l
    ..     end
    .. end
    >> function sp(s, l)
    ..     local s=(s*fall(l)):compress()
    ..     return function()
    ..         s:play()
    ..         timer.new(l * 1000, function() s:stop() end)
    ..     end
    .. end
    >> function melody()
    ..     local function n1(l) l = l or .3 return sp((sig{f=440}*.7+sig{f=430}*.3), l) end
    ..     local function n2(l) l = l or .3 return sp((sig{f=660}*.7+sig{f=650}*.3), l) end
    ..     local function n3(l) l = l or .3 return sp((sig{f=880}*.7+sig{f=870}*.3), l) end
    ..     timer.new(  0, n1())
    ..     timer.new(150, n3())
    ..     timer.new(350, n2())
    ..     timer.new(500, n1())
    ..     timer.new(750, n2())
    ..     timer.new(850, n3())
    .. end
    >> melody()


=== Lua interface ===
LHC uses Lua to leech on it's awesomeness. LHC defines functions and 
tables, that can be used by Lua.


defaults: This table stores some default values.
    defaults.freq = 440           -- default frequency for signals
    defaults.generator = gen.sin  -- default generator

Generators:
    A generator accepts values in [0,1] and returns values in [-1,1],
    i.e.: "function rect(t) if t < 0.5 return -1 else return 1 end" is the
    generator for a rectangular signal.
    Some generators are predefined in the table gen:
      gen.sin
      gen.triangle
      gen.saw
      gen.rect
      gen.whiteNoise       aka  gen.wn
      gen.brownNoise       aka  gen.bn

Signals:
    Signals are the playable items in LHC. To create a signal, use the functions:

    signal{ generator, f = <number or function> } and sig{ ... }:
        Creates a signal function using a generator. Both arguments are optional:
          generator ... the generator. Defaults to defaults.generator.
          f ... frequency of the signal. If not set, defaults.freq is used.
        
        Notice this function takes a table argument, so it uses {} instead of ()!

        To turn down a signal, multiply it by a number (see below).

    Playback is done via:
        signal:play() and
        signal:stop()
    
    Modulation and interesting stuff can be achieved by arithmetic operations on
    signals:

    signal' = signal * number   and   signal' = number * signal
    signal' = signal1 * signal2
    signal' = signal * function(t)
    signal' = signal + number   and   signal' = number + signal
    signal' = signal1 + signal2
    signal' = signal + function(t)

    Envelopes can be done using signal * function(t)

    See example.

    There is also a table 'signals' providing access to all signals:
        signals.stop()      -- stops all signals
        signals.clear()     -- stops and deletes all signals

        signals.threads     -- table containing signals threads. dont touch 
                            -- unless you know what you do.
                            -- this may be useful if you have done something like
                            -- 'sig{gen.sin, f = very complicated}:play()' and 
                            -- want access to this signal.

Filter:
    Filter take a signal and return a signal. There are four meaningful filters:

    Lowpass, which filters out all frequencies above a cutoff frequency.
    In code (reality is a bit more complex though):

        function lowpass(freqency, max) 
            if freqency > max then return 0 end
            return frequency
        end

    Highpass, which filters out all frequencies below a cutoff frequency:

        function lowpass(freqency, min) 
            if freqency < min then return 0 end
            return frequency
        end

    Bandpass, which filters out all frequencies not between two cutoff 
    frequencies:

        function lowpass(freqency, min, max) 
            if freqency < min or frequency > max then 
                return 0 
            end
            return frequency
        end

    Bandreject, which is the opposite of bandpass:

        function lowpass(freqency, min, max) 
            if freqency > min or frequency < max then 
                return 0 
            end
            return frequency
        end


    In LHC, filters are functions on signals:

    Lowpass:
        signal.lp aka. signal.lowpass, i.e.:
        t = s:lp(440) -- pass only frequencies < 440

    Highpass:
        signal.hp aka. signal.highpass, i.e.:
        t = s:hp(440) -- pass only frequencies > 440

    Bandpass:
        signal.bp aka. signal.bandpass, i.e.:
        t = s:bp(430, 450) -- pass frequencies in [430,450]
        
        you can also specify more than one band, with a table argument:
        t = s:bp{ {430,450}, {650,670}, {870,890} }

    Bandreject:
        signal.br aka. signal.bandreject, i.e.:
        t = s:br(430, 450) -- pass frequencies < 430 and > 450

        as with bp, you can specify more than one band.


    Filter Examples:
        flow = sig{gen.bn}:lp(440)
        flow:play()

        pointless = (sig{gen.sin,f=440}*.7 + sig{gen.sin,f=660}*.3):hp(500)
        pointless:play()

        substr = sig{gen.wn}:bp(435,445):normalize()
        substr:play()

Timer:
    
    Timers invoke functions after a certain amount of time. LHC timers have
    a resolution of 1ms. The create a timer:

    timer.new(delay, function)  -- delay is in ms

    Important:
      Timers assure the callback will not be executed before the timer expires.
      It can happen that the timed is called after (delay + x) ms.

    Examples:
      timer.new(1000, function() print("foo") end)
      
      function m() print("Another second passed") timer.new(1000, m) end
      m()


More stuff:

    Normalisation - make quiet signals louder and loud signals more quiet:
       
       signals.normalize(signal, [peak]) -- will scale signal so that the maximum
                                         -- value will be around peak
                                         -- peak is optional.

       Examples:

         sig{gen.wn}:bp(440,441):normalize(.7):play()
         (sig{}+sig{f=660}+sig{f=880}):normalize(.6):play()


    Compression - transform signal values to be in the range [-1:1]. 
    Currently this is done using the tanh function:
        
        signals.compress(signal)

        Example:
          
          (sig{}+sig{f=430}):compress():play()


=== License ===
Copyright (c) 2010 Matthias Richter

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
