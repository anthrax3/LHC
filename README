=== Nedded ===
Lua 5.1
PortAudio v19
FFTW3
GNU Readline (optional, but recommended)
CMake >= 2.6

=== Build instructions ===

Linux:
    $ mkdir build
    $ cd build
    $ ccmake ..
    Press c
    Edit options (if you want/have to)
    Press c again
    Press g to generate Makefile
    $ make

OSX (not tested or even known):
    Propably the same as on Linux, but there should
    be a way to create a XCode project.

Windows (not tested):
    Use CMakeSetup.exe to generate a Makefile.
    Compile.


=== Usage & Example ===
To use:
    $ ./lhc
    <type lua code>

Example:
    $ ./lhc 
    lhc> -- play some signals
    lhc> saw = sig{gen.saw, f=220}
    lhc> saw:play()
    lhc> saw:stop()
    lhc> sin = sig{gen.sin, f=440}
    lhc> sin:play()
    lhc> signals.stop()
    
    lhc> -- mix samples 
    lhc> sawsin = sin * .7 + saw * .3
    lhc> sawsin:play()
    lhc> sawsin:stop()
    
    lhc> -- modulate signals
    lhc> mod = sig{gen.sin,f=100} * sig{gen.triangle,f=1}
    lhc> mod:play()
    lhc> mod:stop()

    lhc> -- the frequency can be a function, too:
    lhc> length = 30
    lhc> function rise(t) return 300 * (1 + t / length) + gen.sin(t) end
    lhc> r = sig{gen.sin, f=rise}
    lhc> r:play()
    lhc> r:stop()

    lhc> -- substractive synthesis is fun!
    lhc> flow = sig{gen.bn}:lp(440)
    lhc> flow:play()
    lhc> defaults.generator = gen.wn
    lhc> t = sig{}:bp(440,445) + sig{}:bp(660,667) + sig{}:bp(878,884)
    lhc> t:play() -- this is way too quiet
    lhc> t:stop()
    lhc> t2 = t:normalize(.9)
    lhc> t2:play()


=== Lua interface ===
LHC uses Lua to leech on it's awesomeness. LHC defines functions and 
tables, that can be used by Lua.


defauts: This table stores some default values.
    defaults.freq = 440           -- default frequency for signals
    defaults.generator = gen.sin  -- default generator

Generators:
    A generator accepts values in [0,1] and returns values in [-1,1],
    i.e.: "function rect(t) if t < 0.5 return -1 else return 1 end" is the
    generator for a rectangular signal.
    Some generators are predefined in the table gen:
      gen.sin
      gen.triangle
      gen.saw
      gen.rect
      gen.whiteNoise       aka  gen.wn
      gen.brownNoise       aka  gen.bn

Signals:
    Signals are the playable items in LHC. To create a signal, use the functions:

    signal{ generator, f = <number or function> } and sig{ ... }:
        Creates a signal function using a generator. Both arguments are optional:
          generator ... the generator. Defaults to defaults.generator.
          f ... frequency of the signal. If not set, defaults.freq is used.
        
        Notice this function takes a table argument, so it uses {} instead of ()!

        To turn down a signal, multiply it by a number (see below).

    Playback is done via:
        signal:play() and
        signal:stop()
    
    Modulation and interesting stuff can be achieved by arithmetic operations on
    signals:

    signal' = signal * number   and   signal' = number * signal
    signal' = signal1 * signal2
    signal' = signal + number   and   signal' = number + signal
    signal' = signal1 + signal2

    See example.

    There is also a table 'signals' providing access to all signals:
        signals.stop()      -- stops all signals
        signals.clear()     -- stops and deletes all signals

        signals.threads     -- table containing signals threads. dont touch 
                            -- unless you know what you do.
                            -- this may be useful if you have done something like
                            -- 'sig{gen.sin, f = very complicated}:play()' and 
                            -- want access to this signal.

Filter:
    Filter take a signal and return a signal. There are four meaningful filters:

    Lowpass, which filters out all frequencies above a cutoff frequency.
    In code (reality is a bit more complex though):

        function lowpass(freqency, max) 
            if freqency > max then return 0 end
            return frequency
        end

    Highpass, which filters out all frequencies below a cutoff frequency:

        function lowpass(freqency, min) 
            if freqency < min then return 0 end
            return frequency
        end

    Bandpass, which filters out all frequencies not between two cutoff 
    frequencies:

        function lowpass(freqency, min, max) 
            if freqency < min or frequency > max then 
                return 0 
            end
            return frequency
        end

    Bandreject, which is the opposite of bandpass:

        function lowpass(freqency, min, max) 
            if freqency > min or frequency < max then 
                return 0 
            end
            return frequency
        end


    In LHC, filters are functions on signals:

    Lowpass:
        signal.lp aka. signal.lowpass, i.e.:
        t = s:lp(440) -- pass only frequencies < 440

    Highpass:
        signal.hp aka. signal.highpass, i.e.:
        t = s:hp(440) -- pass only frequencies > 440

    Bandpass:
        signal.bp aka. signal.bandpass, i.e.:
        t = s:bp(430, 450) -- pass frequencies in [430,450]

    Bandreject:
        signal.br aka. signal.bandreject, i.e.:
        t = s:br(430, 450) -- pass frequencies < 430 and > 450


    Filter Examples:
        flow = sig{gen.bn}:lp(440)
        flow:play()

        pointless = (sig{gen.sin,f=440}*.7 + sig{gen.sin,f=660}*.3):hp(500)
        pointless:play()

        substr = sig{gen.wn}:bp(435,445) * 9
        substr:play()

More stuff:

    Normalisation (make quiet signals louder and loud signals more quiet):
       
       signals.normalize([peak]) -- will scale signal so that the maximum
                                 -- value will be around peak
                                 -- peak is optional.

       Examples:

         sig{gen.wn}:bp(440,441):normalize(.7):play()
         (sig{}+sig{f=660}+sig{f=880}):normalize(.6):play()


=== License ===
Copyright (c) 2010 Matthias Richter

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
